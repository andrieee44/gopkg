// Code generated by "enumer -type=LEDCode"; DO NOT EDIT.

package input

import (
	"fmt"
	"strings"
)

const (
	_LEDCodeName_0      = "LED_NUMLLED_CAPSLLED_SCROLLLLED_COMPOSELED_KANALED_SLEEPLED_SUSPENDLED_MUTELED_MISCLED_MAILLED_CHARGING"
	_LEDCodeLowerName_0 = "led_numlled_capslled_scrolllled_composeled_kanaled_sleepled_suspendled_muteled_miscled_mailled_charging"
	_LEDCodeName_1      = "LED_MAXLED_CNT"
	_LEDCodeLowerName_1 = "led_maxled_cnt"
)

var (
	_LEDCodeIndex_0 = [...]uint8{0, 8, 17, 28, 39, 47, 56, 67, 75, 83, 91, 103}
	_LEDCodeIndex_1 = [...]uint8{0, 7, 14}
)

func (i LEDCode) String() string {
	switch {
	case 0 <= i && i <= 10:
		return _LEDCodeName_0[_LEDCodeIndex_0[i]:_LEDCodeIndex_0[i+1]]
	case 15 <= i && i <= 16:
		i -= 15
		return _LEDCodeName_1[_LEDCodeIndex_1[i]:_LEDCodeIndex_1[i+1]]
	default:
		return fmt.Sprintf("LEDCode(%d)", i)
	}
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LEDCodeNoOp() {
	var x [1]struct{}
	_ = x[LED_NUML-(0)]
	_ = x[LED_CAPSL-(1)]
	_ = x[LED_SCROLLL-(2)]
	_ = x[LED_COMPOSE-(3)]
	_ = x[LED_KANA-(4)]
	_ = x[LED_SLEEP-(5)]
	_ = x[LED_SUSPEND-(6)]
	_ = x[LED_MUTE-(7)]
	_ = x[LED_MISC-(8)]
	_ = x[LED_MAIL-(9)]
	_ = x[LED_CHARGING-(10)]
	_ = x[LED_MAX-(15)]
	_ = x[LED_CNT-(16)]
}

var _LEDCodeValues = []LEDCode{LED_NUML, LED_CAPSL, LED_SCROLLL, LED_COMPOSE, LED_KANA, LED_SLEEP, LED_SUSPEND, LED_MUTE, LED_MISC, LED_MAIL, LED_CHARGING, LED_MAX, LED_CNT}

var _LEDCodeNameToValueMap = map[string]LEDCode{
	_LEDCodeName_0[0:8]:         LED_NUML,
	_LEDCodeLowerName_0[0:8]:    LED_NUML,
	_LEDCodeName_0[8:17]:        LED_CAPSL,
	_LEDCodeLowerName_0[8:17]:   LED_CAPSL,
	_LEDCodeName_0[17:28]:       LED_SCROLLL,
	_LEDCodeLowerName_0[17:28]:  LED_SCROLLL,
	_LEDCodeName_0[28:39]:       LED_COMPOSE,
	_LEDCodeLowerName_0[28:39]:  LED_COMPOSE,
	_LEDCodeName_0[39:47]:       LED_KANA,
	_LEDCodeLowerName_0[39:47]:  LED_KANA,
	_LEDCodeName_0[47:56]:       LED_SLEEP,
	_LEDCodeLowerName_0[47:56]:  LED_SLEEP,
	_LEDCodeName_0[56:67]:       LED_SUSPEND,
	_LEDCodeLowerName_0[56:67]:  LED_SUSPEND,
	_LEDCodeName_0[67:75]:       LED_MUTE,
	_LEDCodeLowerName_0[67:75]:  LED_MUTE,
	_LEDCodeName_0[75:83]:       LED_MISC,
	_LEDCodeLowerName_0[75:83]:  LED_MISC,
	_LEDCodeName_0[83:91]:       LED_MAIL,
	_LEDCodeLowerName_0[83:91]:  LED_MAIL,
	_LEDCodeName_0[91:103]:      LED_CHARGING,
	_LEDCodeLowerName_0[91:103]: LED_CHARGING,
	_LEDCodeName_1[0:7]:         LED_MAX,
	_LEDCodeLowerName_1[0:7]:    LED_MAX,
	_LEDCodeName_1[7:14]:        LED_CNT,
	_LEDCodeLowerName_1[7:14]:   LED_CNT,
}

var _LEDCodeNames = []string{
	_LEDCodeName_0[0:8],
	_LEDCodeName_0[8:17],
	_LEDCodeName_0[17:28],
	_LEDCodeName_0[28:39],
	_LEDCodeName_0[39:47],
	_LEDCodeName_0[47:56],
	_LEDCodeName_0[56:67],
	_LEDCodeName_0[67:75],
	_LEDCodeName_0[75:83],
	_LEDCodeName_0[83:91],
	_LEDCodeName_0[91:103],
	_LEDCodeName_1[0:7],
	_LEDCodeName_1[7:14],
}

// LEDCodeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LEDCodeString(s string) (LEDCode, error) {
	if val, ok := _LEDCodeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LEDCodeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LEDCode values", s)
}

// LEDCodeValues returns all values of the enum
func LEDCodeValues() []LEDCode {
	return _LEDCodeValues
}

// LEDCodeStrings returns a slice of all String values of the enum
func LEDCodeStrings() []string {
	strs := make([]string, len(_LEDCodeNames))
	copy(strs, _LEDCodeNames)
	return strs
}

// IsALEDCode returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LEDCode) IsALEDCode() bool {
	for _, v := range _LEDCodeValues {
		if i == v {
			return true
		}
	}
	return false
}
