package input

import (
	"errors"
	"fmt"
	"math"

	"github.com/andrieee44/gopkg/lib/bitops"
	"github.com/andrieee44/gopkg/linux/uapi/ioctl"
)

// EventPretty represents a single input event with its type and code
// converted to human-readable symbolic names.
type EventPretty struct {
	// Time is the moment the event was generated by the kernel,
	// stored with second and microsecond precision. The exact
	// layout depends on the target architecture and matches the
	// time fields in the C struct input_event.
	Time EventTime

	// Type is the high-level category of the event, expressed as
	// a symbolic name rather than a numeric code.
	Type string

	// Code is the specific identifier within Type, expressed as
	// a symbolic name rather than a numeric code.
	Code string

	// Value holds the data associated with the event.
	// For key events, 0 means release, 1 means press, and 2 means
	// autorepeat. For motion events, it carries the delta or absolute
	// coordinate.
	Value int32
}

// ErrUnsupportedEvent is returned when the device does not support
// the specified input event code.
var ErrUnsupportedEvent error = errors.New("unsupported event")

// GetBitmask performs an ioctl call on fd using a request code returned by
// req, reading a bitmask of up to count bits from the kernel and returning
// the codes whose bits are set. It returns a slice of T values representing
// the bits that were set. An error is returned if obtaining the request
// code, performing the ioctl call, or sizing the buffer fails.
func GetBitmask[T Code](
	fd uintptr,
	req func(length uint32) (uint32, error),
	count T,
) ([]T, error) {
	var (
		buf   []byte
		codes []T
		code  T
		err   error
	)

	buf = bitops.Bytes(count)
	if len(buf) > math.MaxUint32 {
		return nil, fmt.Errorf("buf length is %d: %w", len(buf), ioctl.ErrSizeOverflow)
	}

	_, err = ioctl.GetAny(fd, func() (uint32, error) {
		return req(uint32(len(buf)))
	}, &buf[0])
	if err != nil {
		return nil, fmt.Errorf("failed to get bitmask: %w", err)
	}

	codes = make([]T, 0, count)

	for code = range count {
		if !bitops.Test(buf, code) {
			continue
		}

		codes = append(codes, code)
	}

	return codes, nil
}

// BitmaskReq returns a closure that calls [EVIOCGBIT] for the given
// event code.
func BitmaskReq(event EventCode) func(uint32) (uint32, error) {
	return func(length uint32) (uint32, error) {
		return EVIOCGBIT(event, length)
	}
}

// IsMultiTouch reports whether the given absolute axis code represents a
// multi-touch event, such as contact dimensions, position, tool type, or
// tracking information. Returns true for ABS_MT_* codes, false otherwise.
func IsMultiTouch(abs AbsoluteCode) bool {
	switch abs {
	case ABS_MT_TOUCH_MAJOR,
		ABS_MT_TOUCH_MINOR,
		ABS_MT_WIDTH_MAJOR,
		ABS_MT_WIDTH_MINOR,
		ABS_MT_ORIENTATION,
		ABS_MT_POSITION_X,
		ABS_MT_POSITION_Y,
		ABS_MT_TOOL_TYPE,
		ABS_MT_BLOB_ID,
		ABS_MT_TRACKING_ID,
		ABS_MT_PRESSURE,
		ABS_MT_DISTANCE,
		ABS_MT_TOOL_X,
		ABS_MT_TOOL_Y:
		return true
	default:
		return false
	}
}

// AsCoders converts a slice of type T to a slice of Coder.
func AsCoders[T Code](codes []T) []Coder {
	var (
		coders []Coder
		idx    int
		value  T
	)

	coders = make([]Coder, len(codes))
	for idx, value = range codes {
		coders[idx] = Coder(value)
	}

	return coders
}

// CodeForEventCode returns a [Coder] of the appropriate concrete type for the
// given [EventCode] and numeric code. The concrete [Coder] type constructed
// depends on the event kind â€” for example, [EV_KEY] yields a [KeyCode],
// [EV_REL] yields a [RelativeCode], and so on. Returns [ErrUnsupportedEvent]
// if the event is unrecognized.
func CodeForEventCode(event EventCode, code uint16) (Coder, error) {
	switch event {
	case EV_SYN:
		return SyncCode(code), nil
	case EV_KEY:
		return KeyCode(code), nil
	case EV_REL:
		return RelativeCode(code), nil
	case EV_ABS:
		return AbsoluteCode(code), nil
	case EV_MSC:
		return MiscCode(code), nil
	case EV_SW:
		return SwitchCode(code), nil
	case EV_LED:
		return LEDCode(code), nil
	case EV_SND:
		return SoundCode(code), nil
	case EV_REP:
		return RepeatCode(code), nil
	case EV_FF:
		return FFCode(code), nil
	case EV_PWR:
		return KeyCode(code), nil
	case EV_FF_STATUS:
		return FFStatusCode(code), nil
	default:
		return nil, fmt.Errorf(
			"event %s: failed to convert code: %w",
			event.Pretty(),
			ErrUnsupportedEvent,
		)
	}
}

// PrettifyEvent converts a raw Event into its human-readable form.
// It looks up the symbolic name for the event's type and code, and returns
// an EventPretty with those fields populated as strings. The Time and Value
// fields are copied directly from the original Event. If the type/code
// combination is unknown, an error is returned.
func PrettifyEvent(event Event) (EventPretty, error) {
	var (
		coder Coder
		err   error
	)

	coder, err = CodeForEventCode(event.Type, event.Code)
	if err != nil {
		return EventPretty{}, err
	}

	return EventPretty{
		Time:  event.Time,
		Type:  event.Type.Pretty(),
		Code:  coder.Pretty(),
		Value: event.Value,
	}, nil
}
